import InitializePoints
import PoissonEquation
import numpy as np


# Central point discrete Poisson equation test
def central_potential_test(): 
    """
    Test the discrete Poisson equation for a point mass located at the center of a grid.
    Compares the resulting potential from the Poisson equation, Green's function, and an analytic solution.
    The test also visualizes the potential fields and checks if the Green's function result matches the analytic solution.
    """
    center = [0,0,0]
    grid_size = 32

    # Define grid axis values    
    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]
    
    # Place one particle at exactly the middle point of the grid, obtain
    particles = np.array([[x[16],y[16],z[16]]])
    densityField,_,_,_ = InitializePoints.CreateDensityField(center, particles, grid_size)
    potential = PoissonEquation.discretepoisson(densityField)
    green = PoissonEquation.IsolatedMass(densityField)
    
    # Define analytic expression for Poisson's eq:
    analytic = np.zeros((32,32,32))
    for i in range(0,32):
        for j in range(0,32):
            for k in range(0,32):
                r2 = ((16-i)**2 +(16-j)**2 +(16-k)**2)
                if r2 == 0:
                    analytic[i][j][k] = -32
                else:
                    analytic[i][j][k] = -32/np.sqrt(r2)

    # Plot (comment out to skip)
    PoissonEquation.PlotTestPotential(analytic, x, y, z, grid_size)
    PoissonEquation.PlotTestPotential(potential, x, y, z, grid_size)
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size)
    
    # Test that analytic solution and green's function convolution are nearly identical
    assert not (np.abs(analytic - potential) < 1e-8).all()
    assert (np.abs(analytic - green) < 1e-8).all()


# Spherical potential test
def spherical_potential_green_function_test():
    """
    Test the Green's function for a spherical mass distribution.
    Compares the potential generated by the Green's function with an analytic solution computed by superimposing point sources.
    Visualizes the resulting potential fields and checks the difference between the Green's function and analytic results.
    """
    center = [0,0,0]
    grid_size = 32
    
    # Define grid axis values     
    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]
    
    # Create density field and potential from Green's function     
    densityField = InitializePoints.CreateSphericalShellDensityField(grid_size=32, radius_sq=0.3**2, tol=0.02)
    green = PoissonEquation.IsolatedMass(densityField)
    
    # Define analytic expression for potential from density field:
    analytic = np.zeros((32,32,32))
    # Obtain particle indices
    densidx = np.nonzero(densityField)
    densidx2 = np.zeros(densidx[0].shape)
    particles2 = []
    for num in range(len(densidx2)):
        part = []
        for num2 in range(len(densidx)):
            part.append(densidx[num2][num])
        particles2.append(part)
    partarr = np.array(particles2)
    
    # Set potential values by finding the potential from each point source and superposing them
    for particle in partarr:
        particle_pot = np.zeros((32,32,32))
        for i in range(0,32):
            for j in range(0,32):
                for k in range(0,32):
                    r2 = ((i - particle[0])**2 + (j - particle[1])**2 + (k - particle[2])**2)
                    if r2 == 0:
                        particle_pot[i][j][k] = -32
                    else:
                        particle_pot[i][j][k] = -32/np.sqrt(r2)
        analytic += particle_pot     
    
    # Print difference to find error  
    print(np.abs(analytic - green)) 
    
    # Plot (comment out to skip) 
    PoissonEquation.PlotTestPotential(analytic, x, y, z, grid_size)
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size) 
    
    # Test that analytic solution and green's function convolution are nearly identical
    assert (np.abs(analytic - green) < 1e-8).all()


# Potential from two point particles
def two_part_potential_green_function_test():
    """
    Test the Green's function for a system of two point particles.
    Compares the potential generated by the Green's function with an analytic solution based on the two-point particle distribution.
    Visualizes the resulting potential fields and checks if the Green's function result matches the analytic solution.
    """
    center = [0,0,0]
    grid_size = 32

    # Define grid axis values    
    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]
    
    # Place one particle at exactly the middle point of the grid
    particles = np.array([[x[16], y[2], z[16]], [x[16], y[29], z[16]]])
    densityField,_,_,_ = InitializePoints.CreateDensityField(center, particles, grid_size)
    potential = PoissonEquation.discretepoisson(densityField)
    green = PoissonEquation.IsolatedMass(densityField)
    
    # Define analytic expression for Poisson's eq:
    analytic = np.zeros((32,32,32))
    # Obtain particle indices 
    densidx = np.nonzero(densityField)
    densidx2 = np.zeros(densidx[0].shape)
    particles2 = []
    
    for num in range(len(densidx2)):
        part = []
        for num2 in range(len(densidx)):
            part.append(densidx[num2][num])
        particles2.append(part) 
    partarr = np.array(particles2)
    
    # Set potential values by finding the potential from each point source and superposing them 
    for particle in partarr:
        particle_pot = np.zeros((32,32,32))
        for i in range(0,32):
            for j in range(0,32):
                for k in range(0,32):
                    r2 = ((i - particle[0])**2 + (j - particle[1])**2 + (k - particle[2])**2)
                    if r2 == 0:
                        particle_pot[i][j][k] = -32
                    else:
                        particle_pot[i][j][k] = -32/np.sqrt(r2)
        analytic += particle_pot     

    # Plot (comment out to skip)
    PoissonEquation.PlotTestPotential(analytic, x, y, z, grid_size)
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size) 
    
    # Test that analytic solution and green's function convolution are nearly identical
    assert (np.abs(analytic - green) < 1e-8).all()


def gauss1():
    """
    Test the Green's function for a Gaussian mass distribution.
    Visualizes the potential generated by the Green's function for a Gaussian-shaped density field.
    """
    # Define Gauss parameters
    center = [0,0,0]
    grid_size = 32
    a = 0.2
    ba = 1
    ca = 1
    N = 32**3
    
    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]  
    
    particles = InitializePoints.initializeGaussianPoints(center, a, ba, ca, N) 
    densityField,_,_,_ = InitializePoints.CreateDensityField(center, particles, grid_size)
    green = PoissonEquation.IsolatedMass(densityField)

    # Plot  
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size) 


def gauss2():
    """
    Test the Green's function for a Gaussian mass distribution with different parameters.
    Visualizes the potential generated by the Green's function for a second Gaussian-shaped density field.
    """
    # Define Gauss parameters
    center = [0,0,0]
    grid_size = 32
    a = 0.15
    ba = 0.5
    ca = 2
    N = 32**3   

    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]  
    
    particles = InitializePoints.initializeGaussianPoints(center, a, ba, ca, N) 
    densityField,_,_,_ = InitializePoints.CreateDensityField(center, particles, grid_size)
    green = PoissonEquation.IsolatedMass(densityField)

    # Plot  
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size)


def gauss3():
    """
    Test the Green's function for a Gaussian mass distribution with yet another set of parameters.
    Visualizes the potential generated by the Green's function for a third Gaussian-shaped density field.
    """
    # Define Gauss parameters
    center = [0,0,0]
    grid_size = 32
    a = 0.1
    ba = 1
    ca = 0.3
    N = 32**3   

    x = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[0]
    y = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[1]
    z = np.linspace(-0.5, 0.5, grid_size, endpoint=True) + center[2]  
    
    particles = InitializePoints.initializeGaussianPoints(center, a, ba, ca, N) 
    densityField,_,_,_ = InitializePoints.CreateDensityField(center, particles, grid_size)
    green = PoissonEquation.IsolatedMass(densityField)

    # Plot  
    PoissonEquation.PlotTestPotential(green, x, y, z, grid_size)


# Call statements (comment out as needed) 
central_potential_test() 
spherical_potential_green_function_test()
two_part_potential_green_function_test()

gauss1()
gauss2()
gauss3()
